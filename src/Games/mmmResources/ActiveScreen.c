/*********************************************************************
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                           www.segger.com                           *
**********************************************************************
*                                                                    *
* C-file generated by     nonono,                                           *
*                                                                    *
*        Bitmap Converter (ST) for emWin V5.32.                      *
*        Compiled Oct  8 2015, 11:58:22                              *
*                                                                    *
*        (c) 1998 - 2015 Segger Microcontroller GmbH & Co. KG        *
*                                                                    *
**********************************************************************
*                                                                    *
* Source file: ActiveScreen                                          *
* Dimensions:  320 * 128                                             *
* NumColors:   16bpp: 65536                                          *
*                                                                    *
**********************************************************************
*/

#include <Games/mmmResources/ActiveScreen.h>

extern FLASH_BITMAP bmActiveScreen;

unsigned short _acScreen[40960];

FLASH_BITMAP bmActiveScreen = {
  320, // xSize
  128, // ySize
  640, // BytesPerLine
  16, // BitsPerPixel
  (unsigned char *)_acScreen,  // Pointer to picture data
};

uint8_t Screen_Load_Image(uint16_t col, uint16_t row, const FLASH_BITMAP *image) {
	uint16_t x,y;
	uint16_t xLim,yLim;
	// Check if there are enough pixels in the display matrix to show the image
	if(row+image->height > 128)
	{
		yLim = 128-row;
	}
	else
	{
		yLim=image->height;
	}
	if(col+image->width > 320)
	{
		xLim = 320 - col;
	}
	else
	{
		xLim=image->width;
	}

	const uint16_t *pBuf = (uint16_t*)image->pData;

	for (y=0;y<yLim;y++) {
		for (x=0;x<xLim;x++) {
			if (*(pBuf+(y*image->width)+x) != 0xF81F) {
				_acScreen[((y+row)*320+(x+col))] = *(pBuf+(y*image->width)+x);
			}
		}
	}
	return 0;
}

uint8_t Screen_Load_Image2(const GAME_ROOM *image,uint16_t xInit) {
	uint16_t x,y;

	// Check if there are enough pixels in the display matrix to show the image
	if (image->height > 128) {
		return 1;
	}
	// Parse xInit between max limit
	if(xInit > (image->width-320))
	{
		xInit = image->width-320;
	}


	const uint16_t *pBuf = (uint16_t*)image->pData;
	for (y=0;y<image->height;y++) {
		for (x=xInit;x<xInit+320;x++) {
			_acScreen[(y*320+x-xInit)]=(*(pBuf+(y*image->width)+x));
		}
	}

	return 0;

}

uint8_t Screen_Load_Object(GAME_OBJECT* object,uint16_t xInit, int8_t deep) {
	uint16_t x,y,xStart,xEnd,yStart,yEnd;

	xStart=object->col;
	yStart=object->row;
	xEnd=((object->col+object->width)>(xInit+320))?(xInit+320):(object->col+object->width);
	yEnd=((object->row+object->height)>128)?128:(object->row+object->height);

	// Condiciones para mostrar. que el objeto sea visible, visible a la profundidad que pide, que la columna de inicio esté al menos a la izquierda del final de la pantall y que la columna final esté a la derecha de la columna de inicio
	if(object->visibility==1 && object->deep==deep && (object->col-xInit)<320 && (object->col+object->width)>xInit)
	{

		const uint16_t *pBuf = (uint16_t*)object->pData;
		for (y=yStart;y<yEnd;y++) {
			for (x=xStart;x<xEnd;x++) {
				if(x>=xInit && x<(xInit+320) && *(pBuf+((y-yStart)*object->width)+(x-xStart))!=0xF81F)
				{
					_acScreen[(y*320+x-xInit)]=(*(pBuf+((y-yStart)*object->width)+(x-xStart)));
				}
			}
		}
	}
	return 0;
}



/*************************** End of file ****************************/
